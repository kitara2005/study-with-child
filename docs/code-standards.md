# Code Standards & Development Guidelines

## File & Naming Conventions

### Directory Structure

```
app/                          # Next.js App Router (pages + API)
  api/                        # Route Handlers
    results/route.ts          # POST /api/results
    lessons/[id]/tutor/route.ts
  (auth)/                     # Route group: signup, login (hidden in URL)
    signup/page.tsx
    login/page.tsx
  (app)/                      # Route group: main app pages
    mon/[subject]/page.tsx    # /mon/toan
    mon/[subject]/chuong-[chapter]/page.tsx
    mon/[subject]/chuong-[chapter]/bai-[slug]/page.tsx
  admin/                      # Admin-only routes
    subjects/page.tsx
    chapters/page.tsx
  layout.tsx                  # Root layout
  page.tsx                    # Homepage

components/
  ui/                         # shadcn/ui components (autogenerated)
    button.tsx
    card.tsx
  layout/
    header.tsx
    footer.tsx
    navigation.tsx
  forms/
    exercise-form.tsx
    login-form.tsx
  lessons/
    lesson-view.tsx
    lesson-content.tsx
  shared/
    badge.tsx
    loading-spinner.tsx

lib/
  prisma.ts                   # Prisma client singleton
  utils.ts                    # Shared utilities
  supabase/
    client.ts                 # Browser Supabase client
    server.ts                 # Server Supabase client

prisma/
  schema.prisma               # Database schema
  seed.ts                     # Seed script

types/
  content.ts                  # LessonContent, LessonSection types
  models.ts                   # Derived types from Prisma
  api.ts                      # API request/response types

tests/
  unit/
    lib/utils.test.ts
  e2e/
    auth.spec.ts
    exercise.spec.ts
```

### Naming Rules

| Type               | Pattern                        | Example                              |
| ------------------ | ------------------------------ | ------------------------------------ |
| **Files (TS/TSX)** | `kebab-case`                   | `exercise-form.tsx`, `auth-guard.ts` |
| **Components**     | `PascalCase`                   | `ExerciseForm`, `LessonView`         |
| **Functions**      | `camelCase`                    | `calculateScore()`, `fetchLesson()`  |
| **Constants**      | `UPPER_SNAKE_CASE` (if global) | `MAX_FILE_SIZE = 5MB`                |
| **Folders**        | `kebab-case`                   | `admin/`, `shared-components/`       |
| **Database**       | `snake_case` in schema         | `user_id`, `created_at`              |
| **URL slugs**      | Vietnamese, `slug-case`        | `/mon/toan/chuong-1/bai-phep-cong`   |

**Rationale:** Convention consistency with Next.js ecosystem + Prisma.

---

## Component Patterns

### Server Components (Default)

Use Server Components for data fetching, database queries, and non-interactive content.

```typescript
// app/mon/[subject]/chuong-[chapter]/bai-[slug]/page.tsx
import { prisma } from '@/lib/prisma';
import { LessonView } from '@/components/lessons/lesson-view';

export async function generateStaticParams() {
  // Enable ISR: pre-generate common slugs
  const lessons = await prisma.lesson.findMany();
  return lessons.map(l => ({
    subject: l.chapter.subject.slug,
    chapter: l.chapter.slug,
    slug: l.slug
  }));
}

export const revalidate = 3600; // ISR: revalidate hourly

export default async function LessonPage({ params }) {
  const lesson = await prisma.lesson.findUnique({
    where: {
      slug_chapterId: {
        slug: params.slug,
        chapterId: (await prisma.chapter.findUnique({
          where: { slug: params.chapter }
        }))!.id
      }
    },
    include: {
      chapter: { include: { subject: true } },
      exercises: { orderBy: { orderIndex: 'asc' } }
    }
  });

  if (!lesson) return notFound();

  return <LessonView lesson={lesson} />;
}
```

**Pros:** Zero JS, fast, SEO. **Cons:** No state/events (use Client Components for those).

### Client Components (Interactivity)

Use Client Components only for interactive features (forms, buttons, real-time updates).

```typescript
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';

export function ExerciseForm({ lessonId, exercises }: ExerciseFormProps) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [answers, setAnswers] = useState<Record<string, string>>({});
  const [submitted, setSubmitted] = useState(false);

  async function handleSubmit() {
    const res = await fetch('/api/results', {
      method: 'POST',
      body: JSON.stringify({ lessonId, answers })
    });
    const result = await res.json();
    setSubmitted(true);
    // Show results...
  }

  return (
    <div className="space-y-6">
      <div className="rounded-lg border p-6">
        {/* Exercise display */}
      </div>
      <Button onClick={handleSubmit}>Submit</Button>
    </div>
  );
}
```

**Best Practices:**

- Move Client Components as far down the tree as possible
- Keep Client Components small (single responsibility)
- Prefer Server Components for layout/navigation

### Form Patterns (Zod + React Hook Form)

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

const loginSchema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(6, 'Min 6 chars')
});

type LoginInput = z.infer<typeof loginSchema>;

export function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<LoginInput>({
    resolver: zodResolver(loginSchema)
  });

  async function onSubmit(data: LoginInput) {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify(data)
    });
    if (!res.ok) {
      // Handle error
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <input {...register('email')} />
      {errors.email && <span className="text-red-500">{errors.email.message}</span>}
      {/* ... */}
      <button type="submit">Login</button>
    </form>
  );
}
```

---

## State Management

**Philosophy:** Use URL params + Server Components by default. Add client state only when necessary.

### When to Use State

| Scenario            | Solution               | Example                      |
| ------------------- | ---------------------- | ---------------------------- |
| **Pagination**      | URL params (`?page=2`) | Lesson list with chapters    |
| **Filters**         | URL searchParams       | Exercise type filter         |
| **Form input**      | React state (useState) | Login form, exercise answers |
| **Temporary UI**    | React state            | Modal open/close             |
| **User preference** | localStorage or DB     | Dark mode, language          |

### Avoid Redux/Zustand in MVP

- **Why:** Over-engineering for a simple platform
- **Post-MVP:** Add if needed (multi-step forms, complex filters)

---

## Error Handling

### API Route Error Patterns

```typescript
// app/api/results/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const session = await getSession();
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { lessonId, answers } = await request.json();

    // Validate input
    if (!lessonId || !answers) {
      return NextResponse.json({ error: 'Invalid input' }, { status: 400 });
    }

    const result = await prisma.result.create({
      data: { userId: session.user.id, lessonId, answers, score },
    });

    return NextResponse.json(result, { status: 201 });
  } catch (error) {
    console.error('POST /api/results:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Client Error Handling

```typescript
'use client';

export function ExerciseForm() {
  const [error, setError] = useState<string | null>(null);

  async function handleSubmit() {
    try {
      setError(null);
      const res = await fetch('/api/results', {
        method: 'POST',
        body: JSON.stringify({ /* ... */ })
      });

      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || 'Unknown error');
      }

      // Success...
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Unknown error');
    }
  }

  return (
    <div>
      {error && <Alert className="bg-red-100">{error}</Alert>}
      {/* ... */}
    </div>
  );
}
```

### Prisma Error Handling

```typescript
import { Prisma } from '@prisma/client';

try {
  await prisma.user.create({ data: { email, ... } });
} catch (error) {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    if (error.code === 'P2002') {
      // Unique constraint violation (e.g., email already exists)
      return NextResponse.json({ error: 'Email already exists' }, { status: 409 });
    }
  }
  throw error;
}
```

---

## Testing Strategy

### Unit Tests (Vitest)

Test utilities, formatters, validators.

```typescript
// lib/__tests__/utils.test.ts
import { describe, it, expect } from 'vitest';
import { calculateScore } from '../utils';

describe('calculateScore', () => {
  it('returns 100 for all correct answers', () => {
    const answers = [
      { exerciseId: '1', answer: 'a', correct: true },
      { exerciseId: '2', answer: 'b', correct: true },
    ];
    expect(calculateScore(answers)).toBe(100);
  });

  it('returns 50 for half correct', () => {
    const answers = [
      { exerciseId: '1', answer: 'a', correct: true },
      { exerciseId: '2', answer: 'x', correct: false },
    ];
    expect(calculateScore(answers)).toBe(50);
  });
});
```

### E2E Tests (Playwright)

Test critical user flows.

```typescript
// tests/e2e/exercise.spec.ts
import { test, expect } from '@playwright/test';

test('student can submit exercise and see result', async ({ page }) => {
  await page.goto('http://localhost:3000/auth/login');
  await page.fill('input[name="email"]', 'student@test.com');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');

  // Navigate to lesson
  await page.goto('http://localhost:3000/mon/toan/chuong-1/bai-phep-cong');

  // Select answer
  await page.click('input[value="a"]');
  await page.click('button:has-text("Submit")');

  // Verify result
  await expect(page.locator('text=Score: 100%')).toBeVisible();
});
```

### Run Tests

```bash
# Unit tests
pnpm test

# E2E tests
pnpm test:e2e

# Coverage
pnpm test:coverage
```

---

## Git Workflow

### Branch Naming

```
feature/auth-signup          # New feature
bugfix/exercise-scoring      # Bug fix
refactor/lesson-component    # Refactoring
docs/setup-guide             # Documentation
```

### Commit Messages (Conventional Commits)

```
feat: implement exercise submission API
fix: correct score calculation for multiple choice
refactor: extract lesson content rendering
docs: update API documentation
```

**Format:** `<type>: <subject> (max 50 chars)`

**Types:** `feat`, `fix`, `refactor`, `docs`, `test`, `chore`, `style`, `perf`

### Pull Requests

1. Open PR early (draft if incomplete)
2. Link to issue: `Closes #123`
3. Describe changes, testing approach
4. Request review from 1-2 teammates
5. Squash merge after approval

---

## Linting & Formatting

### ESLint Rules

```javascript
// .eslintrc.json (Next.js preset)
{
  "extends": [
    "next/core-web-vitals",
    "eslint:recommended"
  ],
  "rules": {
    "no-unused-vars": "error",
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "react/no-unescaped-entities": "warn"
  }
}
```

### Prettier Config

```javascript
// .prettierrc.json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "plugins": ["prettier-plugin-tailwindcss"]
}
```

### Pre-commit Hooks (Husky)

```bash
# .husky/pre-commit (auto-runs)
pnpm lint
pnpm format:check
```

**Run locally:**

```bash
pnpm lint                 # Show lint errors
pnpm lint --fix           # Auto-fix
pnpm format               # Format all files
pnpm format:check         # Check without changing
```

---

## TypeScript Patterns

### Type Safety

```typescript
// ✓ Good: Explicit types
function calculateScore(answers: ExerciseAnswer[]): number {
  return (answers.filter(a => a.correct).length / answers.length) * 100;
}

// ✗ Avoid: Implicit any
function calculateScore(answers: any) { ... }

// ✓ Type inference OK for simple cases
const subjects = ['Math', 'Vietnamese']; // inferred: string[]

// ✓ Use Prisma types
import { Prisma } from '@prisma/client';
type LessonWithExercises = Prisma.LessonGetPayload<{
  include: { exercises: true }
}>;
```

### Avoid Type Assertions

```typescript
// ✗ Type assertion (risky)
const user = data as User;

// ✓ Type guard (safe)
function isUser(data: unknown): data is User {
  return typeof data === 'object' && data !== null && 'id' in data;
}
if (isUser(data)) { ... }
```

---

## Performance Guidelines

### Image Optimization

```typescript
import Image from 'next/image';

// ✓ Good: Next.js Image component
<Image
  src="/subjects/math.jpg"
  alt="Math subject"
  width={400}
  height={300}
  priority={true} // For above-the-fold
/>

// ✗ Avoid: HTML img tag (no optimization)
<img src="/subjects/math.jpg" />
```

### Database Query Optimization

```typescript
// ✗ N+1 query problem
const chapters = await prisma.chapter.findMany();
for (const ch of chapters) {
  const lessons = await prisma.lesson.findMany({ where: { chapterId: ch.id } });
}

// ✓ Use include/select
const chapters = await prisma.chapter.findMany({
  include: { lessons: true },
});

// ✓ Or use select for specific fields
const chapters = await prisma.chapter.findMany({
  select: {
    id: true,
    name: true,
    lessons: { select: { id: true, title: true } },
  },
});
```

### ISR Setup

```typescript
// Cache slow-changing content
export const revalidate = 3600; // Revalidate hourly

// Don't cache fast-changing content
export const revalidate = 0; // Revalidate on every request
```

---

## Security Best Practices

### Environment Variables

```bash
# ✓ Public (prefix NEXT_PUBLIC_)
NEXT_PUBLIC_SUPABASE_URL=https://...

# ✓ Server-only (NO prefix)
SUPABASE_SERVICE_ROLE_KEY=...
DATABASE_URL=...
```

**Rule:** Never access server env vars in Client Components.

### Input Validation

```typescript
import { z } from 'zod';

const resultSchema = z.object({
  lessonId: z.string().uuid(),
  answers: z.array(
    z.object({
      exerciseId: z.string().uuid(),
      answer: z.string().min(1),
    })
  ),
});

export async function POST(request: NextRequest) {
  const body = await request.json();
  const result = resultSchema.parse(body); // Throws if invalid
  // Proceed...
}
```

### Authentication

```typescript
// Always check auth on server routes
export async function POST(request: NextRequest) {
  const session = await getSession();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  // Proceed...
}
```

### RLS (Row-Level Security)

Never trust client `user_id` parameter:

```typescript
// ✗ Bad: Trust client parameter
const results = await prisma.result.findMany({
  where: { userId: req.body.userId }, // What if attacker sends different userId?
});

// ✓ Good: Use authenticated session
const session = await getSession();
const results = await prisma.result.findMany({
  where: { userId: session.user.id },
});
```

---

## Documentation Requirements

### Code Comments

Use comments sparingly, prefer self-documenting code:

```typescript
// ✗ Over-commented
const x = y * 100; // Multiply y by 100

// ✓ Self-documenting
const scorePercentage = rawScore * 100;

// ✓ Explain WHY, not WHAT
// Store answers as JSON for flexible schema across exercise types
const answers: Json = [{ exerciseId, answer, correct }];
```

### Function Documentation

```typescript
/**
 * Calculate the percentage score for an exercise result.
 * @param answers - Array of user answers with correctness flags
 * @returns Score as percentage (0-100)
 */
export function calculateScore(answers: ExerciseAnswer[]): number {
  const correct = answers.filter((a) => a.correct).length;
  return Math.round((correct / answers.length) * 100);
}
```

### README Updates

- Update `.md` files when adding new features
- Keep setup instructions current
- Document non-obvious architectural decisions

---

## Development Workflow Checklist

Before committing:

- [ ] Code runs locally without errors
- [ ] Tests pass (`pnpm test`)
- [ ] Linting passes (`pnpm lint`)
- [ ] Formatting passes (`pnpm format:check`)
- [ ] No console errors in browser DevTools
- [ ] Responsive on mobile (375px viewport)

Before opening PR:

- [ ] Branch is up-to-date with main
- [ ] Commit messages are clear (conventional format)
- [ ] No sensitive data committed (.env, tokens, passwords)
- [ ] No large files (>1MB binaries)

Before merging:

- [ ] All CI checks pass (GitHub Actions)
- [ ] Code review approved
- [ ] All conversations resolved
- [ ] Squash merge into main
